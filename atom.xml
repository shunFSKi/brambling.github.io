<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>燕雀</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="https://shunfski.github.io/"/>
  <updated>2019-08-22T12:32:12.998Z</updated>
  <id>https://shunfski.github.io/</id>
  
  <author>
    <name>燕雀</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>20190812随笔</title>
    <link href="https://shunfski.github.io/2019/08/12/20190812%E9%9A%8F%E7%AC%94/"/>
    <id>https://shunfski.github.io/2019/08/12/20190812随笔/</id>
    <published>2019-08-12T06:53:44.000Z</published>
    <updated>2019-08-22T12:32:12.998Z</updated>
    
    <content type="html"><![CDATA[<h2 id="20190812"><a href="#20190812" class="headerlink" title="20190812"></a>20190812</h2><p>  今年六月底女儿出生了，夫人产后恢复良好。除了偶尔的炎症导致的发烧外没有什么大问题。</p><p>  看到女儿的那一刻，突然焦虑和惶恐扑面而来，我知道我没有做好当父亲的准备，亦未尽到儿子的责任，但无论如何我知道我不能让女儿的生活像我一样，这是一定的。</p><p>  最近思绪很乱，总是在想很多乱七八糟的事情。以前从来没有将心中想法记录下来的想法，今日趁着清理博客尝试记录一些东西下来,博客也许是个记录东西的好地方吧，也许几年后我会回头来回味？ 呵呵，随便了。</p><p>  最近心里萌生了一个大计划，哈哈，对我来说是个很大很大的计划，不知道能不能实现呢。总之，现在是0到1的0，我所有计划开始的起点，就是现在<code>2019-08-12 15:12:34</code>，拭目以待，燕雀。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h2 id=&quot;20190812&quot;&gt;&lt;a href=&quot;#20190812&quot; class=&quot;headerlink&quot; title=&quot;20190812&quot;&gt;&lt;/a&gt;20190812&lt;/h2&gt;&lt;p&gt;  今年六月底女儿出生了，夫人产后恢复良好。除了偶尔的炎症导致的发烧外没有什么大问题。&lt;/p
      
    
    </summary>
    
      <category term="随笔" scheme="https://shunfski.github.io/categories/%E9%9A%8F%E7%AC%94/"/>
    
    
      <category term="随笔" scheme="https://shunfski.github.io/tags/%E9%9A%8F%E7%AC%94/"/>
    
  </entry>
  
  <entry>
    <title>Flutter入坑简介及环境配置详解</title>
    <link href="https://shunfski.github.io/2019/03/18/Flutter%E7%8E%AF%E5%A2%83%E9%85%8D%E7%BD%AE%E8%AF%A6%E8%A7%A3/"/>
    <id>https://shunfski.github.io/2019/03/18/Flutter环境配置详解/</id>
    <published>2019-03-18T09:29:57.000Z</published>
    <updated>2019-03-18T15:52:57.279Z</updated>
    
    <content type="html"><![CDATA[<p><img src="https://shunfski-blog.oss-cn-hangzhou.aliyuncs.com/flutterlogo.png" alt="img"></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>配置教程直接往下翻吧，前面都是废话。<br><code>Flutter</code>现在没听过的怕是没几位井中同仁了吧，继<code>React Native</code>大潮后的又一跨平台吊炸天框架。风风火火一年了，我也得借着这个机会赶紧上波末班车（主要是技术老大翻她牌子了）。到目前的体验是较为惊艳。</p><h2 id="Flutter简介"><a href="#Flutter简介" class="headerlink" title="Flutter简介"></a>Flutter简介</h2><p><code>Flutter</code>是<code>Google</code>推出的基于<code>Dart</code>语言开发的跨平台开源<strong>UI框架</strong>，旨在统一纷纷扰扰的跨平台开发框架，在UI层面上多端共用一套<code>Dart</code>代码来实现多平台适配开发。目前应用比较广泛的还是移动端iOS和安卓，虽然传言<code>Fuchsia</code>会是亲儿子项目，那也不是当下考虑的。</p><h3 id="个人观点"><a href="#个人观点" class="headerlink" title="个人观点"></a>个人观点</h3><ul><li>划重点了，<code>Flutter</code>是UI框架，就是写写页面和业务逻辑可以，底层跟第三方的交互还是要通过原生来实现的，是基于<code>MethodChannel</code>来为双方提供通信交互能力，这个后面文章再详细介绍。<strong>所以</strong>，奉劝各位没有移动端开发经验的还是暂时不要折腾了，你没有一点原生知识，真的很难拿下。</li><li><code>Flutter</code>之所以在性能上体现的比<code>RN</code>更为优秀，从技术层面上来说，<code>RN</code>是在 JS 端通过<code>NativeModules</code>来引用原生组件，而<code>Flutter</code>是通过<code>Skia</code>渲染引擎来绘制画面。这中间就少了一层桥接，效率自然是要提升不少。</li><li>生态环境上来说，<code>Flutter</code>才刚刚起步，不过今年和去年相比，显然生态圈已经扩大了一倍，各种插件也开始层出不穷。相比<code>weex</code>来说，那是个什么玩意儿啊。</li><li>跟<code>H5</code>相比。其实怎么说呢，<code>H5</code>到<code>Flutter</code>的底层渲染其实都是<code>Skia</code>。<code>Flutter</code>也只不过是去掉了对低版本标准的支持。<h3 id="适合开发人群"><a href="#适合开发人群" class="headerlink" title="适合开发人群"></a>适合开发人群</h3>原生开发人员。本身就是直接受益者，接触和学习起来十分迅速。<code>Dart</code>和<code>Java</code>语法较为相似。所以现在安卓开发人员对之热情较高。<br>有移动端需求的前端开发人员。前提是要有一定的<code>Java</code>和<code>OC</code>基础。不然总不能完全依靠插件来实现需求吧。<h2 id="Flutter开发环境配置（Mac）"><a href="#Flutter开发环境配置（Mac）" class="headerlink" title="Flutter开发环境配置（Mac）"></a>Flutter开发环境配置（Mac）</h2>这里就只对<code>mac</code>上的环境配置做个简单介绍。因为<code>Flutter</code>本身就是跨平台开发，你要用到<code>iOS</code>开发总得装个<code>Xcode</code>啊，所以只能在<code>mac</code>系统上进行。用<code>Windows</code>的话没有意义吧。<br>如果需要<code>Windows</code>的教程，就看这篇吧：<br><a href="https://www.cnblogs.com/yangyxd/p/8809512.html" target="_blank" rel="noopener">flutter环境搭建Windows</a><h3 id="所需工具"><a href="#所需工具" class="headerlink" title="所需工具"></a>所需工具</h3></li><li>命令行工具</li><li>VSCode/AS、Xcode</li><li>Git<h3 id="详细步骤"><a href="#详细步骤" class="headerlink" title="详细步骤"></a>详细步骤</h3><h4 id="下载Flutter-SDK"><a href="#下载Flutter-SDK" class="headerlink" title="下载Flutter SDK"></a>下载Flutter SDK</h4></li></ul><p>1.下载zip包<br><a href="https://flutter.dev/docs/development/tools/sdk/archive?tab=macos#macos" target="_blank" rel="noopener">https://flutter.dev/docs/development/tools/sdk/archive?tab=macos#macos</a></p><blockquote><p>下载完后解压到你想要存放的文件夹，这里暂定文件夹为<code>flutter_sdk</code>。<br>2.shell</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">cd ../flutter_sdk  //你想要存放SDK的文件夹地址</span><br><span class="line">git clone -b stable https://github.com/flutter/flutter.git</span><br></pre></td></tr></table></figure><h4 id="配置环境变量"><a href="#配置环境变量" class="headerlink" title="配置环境变量"></a>配置环境变量</h4><p>如果没有科学上网工具，需要配置一下环境变量使用镜像来下载所需的文件，否则的话大几率会下载失败；另外就是需要配置sdk的路径方便全局调用<code>flutter</code>命令。<br><strong>先给出相关地址：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flutter国内镜像地址：https://storage.flutter-io.cn</span><br><span class="line">pub国内镜像地址：https://pub.flutter-io.cn</span><br></pre></td></tr></table></figure><p>上面地址并不是一直稳定的，需要长期稳定的镜像地址可以自行在<a href="https://flutter-io.cn/#" target="_blank" rel="noopener">Flutter社区</a>上查看，及时更换最新的地址。<br><strong>下面是具体的配置步骤：</strong></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">//打开配置文件（在shell中操作）</span><br><span class="line">cd $HOME</span><br><span class="line">vim ~/.bash_profile</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">//在打开的页面添加上下面代码</span><br><span class="line">export PATH=../flutter_sdk/flutter/bin:$PATH</span><br><span class="line">export FLUTTER_STORAGE_BASE_URL=https://storage.flutter-io.cn</span><br><span class="line">export PUB_HOSTED_URL=https://pub.flutter-io.cn</span><br></pre></td></tr></table></figure><blockquote><p>上面的三条地址分别是:<br>配置<code>flutter</code>全局路径；<br>配置<code>flutter</code>镜像地址；<br>配置<code>pub</code>镜像地址；这里不知道<code>pub</code>是什么的暂时不用管，这里一起配置上，后面会提到。</p></blockquote><blockquote><p>其中要将<code>../flutter_sdk</code>替换为你自己的<code>sdk</code>存放路径。例如：<code>/Users/fengshun/workFeng/Flutter</code><br><img src="https://shunfski-blog.oss-cn-hangzhou.aliyuncs.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-03-18%20%E4%B8%8B%E5%8D%8811.09.45.png" alt="img"><br>配置完成后，再调用下面命令使之生效。下次无论在哪打开<code>shell</code>都可以使用<code>flutter</code>命令；</p></blockquote><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">source ~/.bash_profile</span><br></pre></td></tr></table></figure><blockquote><p>这里有个坑点要注意：有的小伙伴可能会发现配置完后每次重新打开终端都要重新<code>source ~/.bash_profile</code>才可以正常使用<code>flutter</code>命令；<br>这是因为<code>zsh</code>加载的是 <code>~/.zshrc</code>文件，而<code>.zshrc</code>文件中并没有定义任务环境变量。<br>解决办法是在<code>.zshrc</code>里面加入一行<code>source ~/.bash_profile</code>。配置方法跟上面相同，不再赘述。</p></blockquote><p>这个时候就可以使用<code>flutter</code>命令了，现在打开终端，运行：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter -h</span><br></pre></td></tr></table></figure><p>正常的话就会出来<code>flutter</code>的命令帮助简介；<br><img src="https://shunfski-blog.oss-cn-hangzhou.aliyuncs.com/flutter_h.gif" alt="img"></p><h4 id="检查环境"><a href="#检查环境" class="headerlink" title="检查环境"></a>检查环境</h4><p>上面的环境配好以后，就可以运行<code>flutter</code>检查命令了，如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter doctor</span><br></pre></td></tr></table></figure><p>接下来<code>flutter</code>会自动检查你当前的电脑环境有什么缺失的配置，最后会出来下图所示：<br><img src="https://shunfski-blog.oss-cn-hangzhou.aliyuncs.com/flutter%20doctor.png" alt="img"><br>其中[✓]是通过，[✗]是不通过。下面简要解释一下这几条：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">1、flutter当前分支，版本号，系统环境</span><br><span class="line">2、开发所需要的安卓开发工具链</span><br><span class="line">3、开发需要的iOS开发工具链</span><br><span class="line">4、Android Studio安装情况</span><br><span class="line">5、有没有已连接的可用设备（一般是手机设备）</span><br></pre></td></tr></table></figure><blockquote><p>因为我电脑已经安装过，没法展示所有的报错信息，这里简要列出几个重要的问题说明一下；</p></blockquote><blockquote><p>看到绿色[✓]自然不需要去关注，红色[✗]也不需要慌，按照每条的提示信息逐步输入命令安装对应的文件就可以了，这里建议使用科学上网工具来下载，不然可能会失败；<br>其中第四条报错其实是因为没有安装<code>Android Studio</code>，这个其实无所谓，像我就是使用<code>VScode</code>来开发，看你选择，不安装其实也是可以的。</p></blockquote><h5 id="flutter-doctor-–android-licenses"><a href="#flutter-doctor-–android-licenses" class="headerlink" title="flutter doctor –android-licenses"></a>flutter doctor –android-licenses</h5><p>看到<code>android-licenses</code>字眼，直接执行，然后一路确认下去就可以了。就是安装安卓证书。</p><h5 id="cocoapods安装"><a href="#cocoapods安装" class="headerlink" title="cocoapods安装"></a>cocoapods安装</h5><p>看到<code>cocoapods</code>、<code>pod</code>字眼；这个一般安卓开发不太了解，是<code>iOS</code>开发用到的第三方管理工具，和上面提到的<code>flutter</code>的<code>pub</code>作用相似，安装也需要设置镜像，详细安装方法这里提供一个详细地址自己查看：<br><a href="https://juejin.im/post/5b0e69fdf265da08d057b362" target="_blank" rel="noopener">cocoapods安装</a><br>这里注意的是如果你自己搜到一些安装教程，切记镜像源要设置为<code>ruby-china</code>的，<code>taobao</code>的镜像源很早以前就不再维护了。详细的看这个网址<a href="https://gems.ruby-china.com/" target="_blank" rel="noopener">ruby-china镜像源</a>，把地址换位网址内提供的镜像地址。</p><blockquote><p><code>cocoapods</code>安装完成后，所有<code>pod</code>相关的命令依次执行下去，直到<code>flutter doctor</code>不再列出相关错误为止。</p></blockquote><h5 id="iOS-toolchain"><a href="#iOS-toolchain" class="headerlink" title="iOS toolchain"></a>iOS toolchain</h5><p>这个唯一的也是最有效的解决方式就是下载最新版的<code>Xcode</code>，基本就会解决相应的所有问题，下载地址在<code>App Store</code>；所以我前文提到建议使用<code>mac</code>开发，当然，<strong>如果你只需要开发安卓，这条和上面<code>cocoapods</code>那条可以一并忽略其报错信息</strong>。</p><p>所有都安装完成的话，就是我这样的一片绿了：<br><img src="https://shunfski-blog.oss-cn-hangzhou.aliyuncs.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-03-18%20%E4%B8%8B%E5%8D%8811.16.00.png" alt="img"><br>一般线上开发肯定需要使用稳定版本的<code>SDK</code>，平时开发中如果想要查看或者切换分支，可以使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flutter channel //查看所有分支和当前分支</span><br><span class="line">flutter channel master //切换到master分支</span><br></pre></td></tr></table></figure><p>要更新当前分支到最新版本：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flutter upgrade</span><br></pre></td></tr></table></figure><p>其实直接<code>cd</code>到<code>flutter SDK</code>的文件夹下用<code>git</code>更新也是一样的。<br>以上完成后，基本<code>flutter</code>的开发环境就完全搭建起来了，接下来继续<code>Android Studio</code>和<code>VScode</code>的设置。</p><h4 id="Android-Studio-VScode安装flutter插件"><a href="#Android-Studio-VScode安装flutter插件" class="headerlink" title="Android Studio/VScode安装flutter插件"></a>Android Studio/VScode安装flutter插件</h4><h5 id="Android-Studio"><a href="#Android-Studio" class="headerlink" title="Android Studio"></a>Android Studio</h5><p>Preferences =&gt; Plugins =&gt; search flutter安装<br>详细见图：<br><img src="https://shunfski-blog.oss-cn-hangzhou.aliyuncs.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-03-18%20%E4%B8%8B%E5%8D%888.57.22.png" alt="img"><br><img src="https://shunfski-blog.oss-cn-hangzhou.aliyuncs.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-03-18%20%E4%B8%8B%E5%8D%888.57.47.png" alt="img"></p><h5 id="VScode"><a href="#VScode" class="headerlink" title="VScode"></a>VScode</h5><p><code>Flutter</code>安装见图：<br><img src="https://shunfski-blog.oss-cn-hangzhou.aliyuncs.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-03-18%20%E4%B8%8B%E5%8D%889.14.24.png" alt="img"><br><code>Dart</code>安装同上；</p><blockquote><p>这里有个编译配置需要注意一下，安卓真机编译<code>apk</code>安装的时候有时候会出现闪退，要添加编译选项<code>--target-platform android-arm</code>，详见<a href="https://github.com/flutter/flutter/issues/18494" target="_blank" rel="noopener">flutter issue</a>。<br><code>Android Studio</code>：在项目的编译选项<code>Additional arguments</code>中添加；<br><code>VScode</code>：在项目的<code>.vscode/launch.json</code>中添加；<br>详细见图：<br><img src="https://shunfski-blog.oss-cn-hangzhou.aliyuncs.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-03-18%20%E4%B8%8B%E5%8D%888.59.35.png" alt="img"><br><img src="https://shunfski-blog.oss-cn-hangzhou.aliyuncs.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-03-18%20%E4%B8%8B%E5%8D%889.35.47.png" alt="img"></p></blockquote><h4 id="创建并运行demo"><a href="#创建并运行demo" class="headerlink" title="创建并运行demo"></a>创建并运行demo</h4><p>创建<code>flutter</code>工程有两种方式，一种直接命令创建，个人喜欢这种，方便简洁；另一种就是通过可视化<code>IDE</code>来创建了；下面分别简单介绍一下，主要以<code>VScode为主</code>。</p><blockquote><p>这里项目命名记得需要小写字母加下划线组成。</p></blockquote><h5 id="命令创建"><a href="#命令创建" class="headerlink" title="命令创建"></a>命令创建</h5><p>在对应的文件目录下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">flutter creat flutter_demo //创建一个Java和OC的项目</span><br><span class="line">flutter create -i swift -a kotlin flutter_demo //创建一个kotlin和swift的项目</span><br></pre></td></tr></table></figure><p><img src="https://shunfski-blog.oss-cn-hangzhou.aliyuncs.com/flutter_demo.gif" alt="img"></p><blockquote><p>flutter项目默认是支持<code>Java</code>和<code>OC</code>的，如果需要添加对<code>kotlin</code>和<code>swift</code>的支持，需要按照上面第二条来创建</p></blockquote><h5 id="Android-Studio创建"><a href="#Android-Studio创建" class="headerlink" title="Android Studio创建"></a>Android Studio创建</h5><p>File =&gt; New =&gt; New Flutter Project =&gt; Flutter Application<br>如图：<br><img src="https://shunfski-blog.oss-cn-hangzhou.aliyuncs.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-03-18%20%E4%B8%8B%E5%8D%8810.22.01.png" alt="img"><br><img src="https://shunfski-blog.oss-cn-hangzhou.aliyuncs.com/%E5%B1%8F%E5%B9%95%E5%BF%AB%E7%85%A7%202019-03-18%20%E4%B8%8B%E5%8D%8810.22.21.png" alt="img"></p><blockquote><p>提示找不到<code>Dart</code>支持的记得去设置里面添加一下<code>flutter</code>的路径。</p></blockquote><h5 id="VScode创建"><a href="#VScode创建" class="headerlink" title="VScode创建"></a>VScode创建</h5><p>同命令行，创建完成用<code>VScode</code>打开</p><h5 id="运行demo"><a href="#运行demo" class="headerlink" title="运行demo"></a>运行demo</h5><p>刚创建的<code>demo</code>会有一个计数器示例，找到<code>main.dart</code>文件运行或者直接<code>flutter run</code>就可以运行整个项目。</p><blockquote><p>这里要注意的是，如果在网上下载了别的项目<code>demo</code>需要运行，要先在<code>pubspec.yaml</code>文件内下载第三方包或者直接运行<code>flutter packages get</code>，直到项目不再报错就可以运行了。<br>一切顺利的话，就可以看到如下图所示的项目了：<br><img src="https://shunfski-blog.oss-cn-hangzhou.aliyuncs.com/flutter_dm.gif" alt="img"></p></blockquote><p>到这里，基本上环境配置教程就完成了，亲自去感受一下实时渲染的效果吧。更多详细学习进度敬请关注。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;p&gt;&lt;img src=&quot;https://shunfski-blog.oss-cn-hangzhou.aliyuncs.com/flutterlogo.png&quot; alt=&quot;img&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot;
      
    
    </summary>
    
      <category term="Flutter" scheme="https://shunfski.github.io/categories/Flutter/"/>
    
    
      <category term="技术" scheme="https://shunfski.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="Flutter" scheme="https://shunfski.github.io/tags/Flutter/"/>
    
  </entry>
  
  <entry>
    <title>iOS自适应cell行高的那点破事儿</title>
    <link href="https://shunfski.github.io/2017/08/07/FSAutoAdjust-cellHeightDemo/"/>
    <id>https://shunfski.github.io/2017/08/07/FSAutoAdjust-cellHeightDemo/</id>
    <published>2017-08-06T18:25:00.000Z</published>
    <updated>2017-08-07T06:28:32.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1792044-a515cbcccd180643.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="=-=.jpeg"><br><a href="https://github.com/shunFSKi/FSAutoAdjust-cellHeightDemo" target="_blank" rel="noopener">FSAutoAdjust-cellHeightDemo</a></p><h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>其实早就准备写这篇文章了，但是一直没有系统去整理一下相关的demo，加上最近离职了，各种事情忙的有点郁闷，所以一直拖沓了下来。回家休息了一段时间想起来写了一半的demo，在还没找工作的这段空挡时间抽空完善了一下再写篇说明文档备忘一下。</p><a id="more"></a><p>##需求背景<br>iOS的cell行高自适应是个非常常见的需求，也是一个非常简单的需求，之前我遇到过很多小伙伴不知道怎么来实现，在这里就一步步的来分析一下，供大家参考。</p><h2 id="问题分析"><a href="#问题分析" class="headerlink" title="问题分析"></a>问题分析</h2><p>其他的实现场景就不说了，我们现在来分析一下具体的需求，如图所示：<br><img src="http://upload-images.jianshu.io/upload_images/1792044-ab99688501e50247.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="cell行高自适应.png"></p><p>其实主要实现这几点就可以解决所谓的自适应行高的问题，下面我们就来逐步实现这个需求。</p><h2 id="计算UITableViewCell的高度"><a href="#计算UITableViewCell的高度" class="headerlink" title="计算UITableViewCell的高度"></a>计算UITableViewCell的高度</h2><p>说到计算高度，大家都不陌生，最简单常见的就是计算出每个子视图的高度累积起来返回我们所需要的<code>cell</code>高度，然后在<code>UITableViewDelegate</code>中调用：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">CGFloat</span>)tableView:(<span class="built_in">UITableView</span> *)tableView heightForRowAtIndexPath:(<span class="built_in">NSIndexPath</span> *)indexPath</span><br><span class="line">&#123;</span><br><span class="line">   <span class="keyword">return</span> <span class="number">666</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>或者高度固定的情况下直接</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.tableView.rowHeight = <span class="number">666</span>;</span><br></pre></td></tr></table></figure><p>但是这就要求我们需要提前拿到model中的数据来手动计算每个控件的高度，这样既麻烦又不能通用，所以在<code>autolayout</code>出来之后我们只要给<code>cell</code>的<code>contentView</code>的上下左右都添加了约束，系统就可以自动的帮我们实现高度的自适应，就是一定要保证<code>cell</code>的高度可以被子视图撑开就可以了，利用的是<code>systemLayoutSizeFittingSize</code>这个<code>API</code>；<br>iOS8之后就更简单了，直接使用：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">self</span>.tableView.estimatedRowHeight = <span class="number">666</span>;</span><br><span class="line"><span class="keyword">self</span>.tableView.rowHeight = <span class="built_in">UITableViewAutomaticDimension</span>;</span><br></pre></td></tr></table></figure><p>就可以了，其中<code>estimatedRowHeight</code>是预估高度，这里要注意<code>delegate</code>中的返回高度方法就不用在写了。<br>关于这方面的文章，<code>UITableView+FDTemplateLayoutCel</code>的作者写的一篇文章十分详细，建议先去了解一下（<a href="http://blog.sunnyxx.com/2015/05/17/cell-height-calculation/" target="_blank" rel="noopener">优化UITableViewCell高度计算的那些事</a>）<br>但是这个方法实际上在有多个子视图的<code>cell</code>上滑动是很卡顿的，特别是在iOS8尤其是iOS10上卡顿尤为明显，这跟系统的算高机制有一定关系，具体可以看上面的文章，这里不再解释了。<br>如果脱离开<code>autolayout</code>来说，平时计算高度的话，最开始都是根据<code>cell</code>内子控件内容的高度来手动累加起来，但是这个方法每次都要去手动处理其中的算高逻辑，而且横竖屏切换的时候还要重新计算，在平时开发中就会浪费大量不必要的精力。所以后来我在项目中是通过调用<code>layoutSubviews</code>来获取到子控件的实际<code>frame</code>，这样就可以得到我们所需的<code>cell</code>高度值，如下代码所示：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">cell.frame = <span class="built_in">CGRectSetWidth</span>(cell.frame, contentViewWidth);</span><br><span class="line">    cell.contentView.frame = <span class="built_in">CGRectSetWidth</span>(cell.contentView.frame, <span class="built_in">CGRectGetWidth</span>(tableView.frame));</span><br><span class="line">    [cell layoutIfNeeded];</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">UIView</span> *cellBottomView = <span class="literal">nil</span>;</span><br><span class="line">    <span class="keyword">if</span> (cell.FS_cellBottomView) &#123;</span><br><span class="line">        cellBottomView = cell.FS_cellBottomView;</span><br><span class="line">    &#125;<span class="keyword">else</span> <span class="keyword">if</span> (cell.FS_cellBottomViews &amp;&amp; cell.FS_cellBottomViews.count &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        cellBottomView = cell.FS_cellBottomViews[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">UIView</span> *view <span class="keyword">in</span> cell.FS_cellBottomViews) &#123;</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">CGRectGetMaxY</span>(view.frame) &gt; <span class="built_in">CGRectGetMaxY</span>(cellBottomView.frame)) &#123;</span><br><span class="line">                cellBottomView = view;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">NSArray</span> *contentViewSubViews = cell.contentView.subviews;</span><br><span class="line">        <span class="keyword">if</span> (contentViewSubViews.count == <span class="number">0</span>) &#123;</span><br><span class="line">            cellBottomView = cell.contentView;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            cellBottomView = contentViewSubViews[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span> (<span class="built_in">UIView</span> *view <span class="keyword">in</span> contentViewSubViews) &#123;</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">CGRectGetMaxY</span>(view.frame) &gt; <span class="built_in">CGRectGetMaxY</span>(cellBottomView.frame)) &#123;</span><br><span class="line">                    cellBottomView = view;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">CGFloat</span> cellHeight = <span class="built_in">CGRectGetMaxY</span>(cellBottomView.frame) + bottomOffset;</span><br></pre></td></tr></table></figure><p>其中的<code>cellBottomView</code>是位于<code>cell</code>最底部的子视图，为了提高计算效率最好传入，如果不确定哪个子视图在最下面，可以传入一个视图数组<code>contentViewSubViews</code>，详细使用方式可以查看demo。</p><h2 id="缓存cell高度"><a href="#缓存cell高度" class="headerlink" title="缓存cell高度"></a>缓存cell高度</h2><p>高度计算出来后，正常来说我们的需求已经达到了，但是如果这个高度值每次滑动的时候由于<code>cell</code>的复用机制都会重新计算，若果这个<code>cell</code>的自定义样式很复杂，子视图太多，那么大量的计算一定会损耗性能而导致明显的卡顿，所以缓存机制就是个必要的措施，更何况苹果也建议这样做；<br>demo提供了两个计算行高的<code>API</code>：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> cell自动计算行高</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param tableView tableView</span></span><br><span class="line"><span class="comment"> @param indexPath indexPath</span></span><br><span class="line"><span class="comment"> @param contentViewWidth cell内容宽度，不确定可传0</span></span><br><span class="line"><span class="comment"> @return cell高度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="built_in">CGFloat</span>)FSCellHeightForTableView:(<span class="built_in">UITableView</span> *)tableView indexPath:(<span class="built_in">NSIndexPath</span> *)indexPath cellContentViewWidth:(<span class="built_in">CGFloat</span>)contentViewWidth bottomOffset:(<span class="built_in">CGFloat</span>)bottomOffset;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> cell自动计算行高优化版</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param tableView tableView</span></span><br><span class="line"><span class="comment"> @param indexPath indexPath</span></span><br><span class="line"><span class="comment"> @param cacheKey 当前cell唯一标识符</span></span><br><span class="line"><span class="comment"> @param contentViewWidth cell内容宽度，不确定可传0</span></span><br><span class="line"><span class="comment"> @return cell高度</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">+ (<span class="built_in">CGFloat</span>)FSCellHeightForTableView:(<span class="built_in">UITableView</span> *)tableView indexPath:(<span class="built_in">NSIndexPath</span> *)indexPath cacheKey:(<span class="built_in">NSString</span> *)cacheKey cellContentViewWidth:(<span class="built_in">CGFloat</span>)contentViewWidth bottomOffset:(<span class="built_in">CGFloat</span>)bottomOffset;</span><br></pre></td></tr></table></figure><p>第一种使用数组来做缓存，传入对应<code>cell</code>的<code>indexPath</code>作为数组索引值；第二种则采用字典来缓存数据，要求传入一个唯一标识符<code>cacheKey</code>来区分；<br>两种方式都可以准确获得<code>cell</code>高度，第一种实现更简洁，缺点就是数据源发生变化时，所有的缓存就会清空重新计算后缓存，比如<code>reloadData</code>的时候；第二种就是在前者的基础上添加一个区分不同<code>cell</code>的标识符，使用时还是建议使用第二种，不会清空缓存数据，轻量级页面没什么区别。总之两种方法都做了缓存数据的容错处理，支持以下方法：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">@selector</span>(reloadData),</span><br><span class="line">        <span class="keyword">@selector</span>(insertSections:withRowAnimation:),</span><br><span class="line">        <span class="keyword">@selector</span>(deleteSections:withRowAnimation:),</span><br><span class="line">        <span class="keyword">@selector</span>(reloadSections:withRowAnimation:),</span><br><span class="line">        <span class="keyword">@selector</span>(moveSection:toSection:),</span><br><span class="line">        <span class="keyword">@selector</span>(insertRowsAtIndexPaths:withRowAnimation:),</span><br><span class="line">        <span class="keyword">@selector</span>(deleteRowsAtIndexPaths:withRowAnimation:),</span><br><span class="line">        <span class="keyword">@selector</span>(reloadRowsAtIndexPaths:withRowAnimation:),</span><br><span class="line">        <span class="keyword">@selector</span>(moveRowAtIndexPath:toIndexPath:)</span><br></pre></td></tr></table></figure><h2 id="兼容横竖屏"><a href="#兼容横竖屏" class="headerlink" title="兼容横竖屏"></a>兼容横竖屏</h2><p>这个需求实现较为简单，就是横屏和竖屏分别采用两套缓存数据，互不影响，切换横竖屏的时候自动切换数据源。</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="built_in">NSMutableArray</span> *)indexCacheArrForCurrentOrientation</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">UIDeviceOrientationIsPortrait</span>([<span class="built_in">UIDevice</span> currentDevice].orientation) ? <span class="keyword">self</span>.indexCacheArr_Portrait: <span class="keyword">self</span>.indexCacheArr_Landscape;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最后实现的效果如图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/1792044-1cffe0a6b5c9220b.gif?imageMogr2/auto-orient/strip" alt="FSAutoAdjust-cellHeightDemo.gif"></p><p>总之答题思路就是这些，使用方便，感兴趣的可以移步下载demo查看：<a href="https://github.com/shunFSKi/FSAutoAdjust-cellHeightDemo" target="_blank" rel="noopener">FSAutoAdjust-cellHeightDemo</a></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1792044-a515cbcccd180643.jpeg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;=-=.jpeg&quot;&gt;&lt;br&gt;&lt;a href=&quot;https://github.com/shunFSKi/FSAutoAdjust-cellHeightDemo&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;FSAutoAdjust-cellHeightDemo
&lt;/a&gt;&lt;/p&gt;
&lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;其实早就准备写这篇文章了，但是一直没有系统去整理一下相关的demo，加上最近离职了，各种事情忙的有点郁闷，所以一直拖沓了下来。回家休息了一段时间想起来写了一半的demo，在还没找工作的这段空挡时间抽空完善了一下再写篇说明文档备忘一下。&lt;/p&gt;
    
    </summary>
    
      <category term="框架" scheme="https://shunfski.github.io/categories/%E6%A1%86%E6%9E%B6/"/>
    
    
      <category term="技术" scheme="https://shunfski.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="iOS" scheme="https://shunfski.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS一步步实现一个高度自定义UIButton控件</title>
    <link href="https://shunfski.github.io/2017/06/26/FSCustomButtonDemo/"/>
    <id>https://shunfski.github.io/2017/06/26/FSCustomButtonDemo/</id>
    <published>2017-06-26T09:28:00.000Z</published>
    <updated>2017-06-28T14:55:52.000Z</updated>
    
    <content type="html"><![CDATA[<p><img src="http://upload-images.jianshu.io/upload_images/1792044-1a0d693d2497a0a7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="=-=.jpg"></p><h2 id="需求背景"><a href="#需求背景" class="headerlink" title="需求背景"></a>需求背景</h2><p>日常开发中<code>UIButton</code>的图片与标题默认的布局是固定的，是在水平方向左右排列。但是我们会经常需要更改<code>image</code>和<code>title</code>的位置来实现需求，这是个很常见的需求就不多说了。所以下面就来谈谈如何一步步的实现一个高度自定义的<code>UIButton</code>控件。</p><a id="more"></a><h2 id="实现思路"><a href="#实现思路" class="headerlink" title="实现思路"></a>实现思路</h2><p>默认情况下，在<code>button</code>有固定的宽高值的时候，<code>image</code>和<code>title</code>是以相对左右排列，整体居中于<code>button</code>来显示的，如果没有固定的宽高值，即大小自适应的情况下，整个<code>UIButton</code>将自动缩放到刚好可以容纳<code>image</code>和<code>title</code>的大小。如图所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/1792044-fc8373cebaf3d4ec.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="自适应大小.png"></p><p><strong>了解UIButton的各个属性</strong><br>在准备自定义之前，我们需要了解<code>UIButton</code>的各个属性都是怎么运用和实现的，因为要修改<code>title</code>和<code>image</code>的位置与这些属性是密不可分的。<br>因为这些都是基本的开发知识，我就不再过多叙述，分别以图片来展示效果：</p><p><strong>UIControlContentVerticalAlignment</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/1792044-8f8b64f133d47c54.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UIControlContentVerticalAlignment各种效果.png"></p><p><strong>UIControlContentHorizontalAlignment</strong></p><p><img src="http://upload-images.jianshu.io/upload_images/1792044-c8b5cb49ef26e67a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="UIControlContentHorizontalAlignment各种效果.png"></p><p>通过上面两张图可以清楚地看到<code>UIControlContentVerticalAlignment</code>和<code>UIControlContentHorizontalAlignment</code>在不同值下的效果，灰色背景的就是一个<code>button</code>的实际大小，<code>center</code>就是系统默认的值，明显的在两种<code>fill</code>值下，图片都出现了拉伸的情况，而且在水平<code>fill</code>下，图片并没有像垂直情况下水平铺满整个控件，<code>image</code>和<code>title</code>还重叠到了一起去。</p><p><strong>UIEdgeInsets</strong></p><p><code>UIButton</code>的另一个重要的属性就是这个了，称之为偏移量，他分别有<code>contentEdgeInsets</code>，<code>imageEdgeInsets</code>，<code>titleEdgeInsets</code>三个相关属性。<br>默认情况下：</p><ul><li><code>contentEdgeInsets</code>的<code>top</code>、<code>left</code>、<code>bottom</code>、<code>right</code>都是相对于<code>button</code>本身，控制着<code>image</code>和<code>title</code>整体的偏移量；</li><li><code>imageEdgeInsets</code>的<code>top</code>、<code>left</code>、<code>bottom</code>相对于<code>button</code>，<code>right</code>相对于<code>title</code>，控制着<code>image</code>的相对偏移量；</li><li><code>titleEdgeInsets</code>的<code>top</code>、<code>bottom</code>、<code>right</code>相对于<code>button</code>，<code>left</code>相对于<code>image</code>，控制着<code>title</code>的相对偏移量；</li></ul><p>我用一张图来解释一下：<br><img src="http://upload-images.jianshu.io/upload_images/1792044-b4ed0d2e5ca6b73e.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="偏移量.png"><br>上图的正负值就代表偏移方向</p><p><strong>我们想要的效果</strong><br>写到这里，我们需要考虑一下我们的需求，我们并不是来分析<code>button</code>的实现原理，而是要实现一个自定义的<code>button</code>，自定义<code>image</code>和<code>title</code>的相对位置是最起码的要求。相信看到这里大家也知道我们只需要修改<code>imageEdgeInsets</code>和<code>titleEdgeInsets</code>的值就可以随意布局<code>image</code>和<code>title</code>的相对位置。比如左<code>title</code>右<code>image</code>，上<code>image</code>下<code>title</code>。<br>要实现这个需求有两种方式：</p><ul><li>新建一个<code>UIButton</code>的分类<code>UIButton + xx</code>，在<code>layoutSubviews</code>里修改<code>imageEdgeInsets</code>和<code>titleEdgeInsets</code>的值。这种方式可以简单实现我们的基本需求，但如果想要添加更多的自定义属性还需要通过<code>runtime</code>来实现，好处就是拥有调用系统<code>API</code>的舒爽，直接<code>UIButton</code>调用，没什么代码侵入性。</li><li>封装一个继承自<code>UIButton</code>的<code>CustomButton</code>，可以自由添加自定义方法、属性，在<code>layoutSubviews</code>里重置<code>image</code>和<code>title</code>的<code>frame</code>来实现不同的布局方式。</li></ul><p>其实这两种方式都可以实现自定义的效果，具体选用哪个就看你自己的需求了，我这里就第二种方式来实现一下。</p><p>上面所说到的<code>contentEdgeInsets</code>，<code>imageEdgeInsets</code>，<code>titleEdgeInsets</code>默认值都是<code>zero</code>，但是我们现在假设他们都有一个默认值<code>x</code>；<br><img src="http://upload-images.jianshu.io/upload_images/1792044-344f251018829098.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="button简易图示.png"></p><p>这里实现的思路就是通过<code>self.bounds</code>减去四周的偏移量先获取整个<code>content</code>的实际<code>size</code>，再由<code>contentSize</code>减去<code>image</code>和<code>title</code>的对应偏移量来获取<code>image</code>和<code>title</code>的实际<code>size</code>。总之就是先获取<code>image</code>和<code>title</code>的实际大小，然后根据不同的布局重置<code>image</code>和<code>title</code>的<code>x</code>、<code>y</code>坐标和<code>bound</code>，从而得到对应的<code>frame</code>，就可以实现自由布局了。</p><p>上面所说的是<code>button</code>有固定宽高值的情况，如果<code>button</code>的宽高自适应，即调用<code>sizeToFit</code>方法时，我们需要在<code>- (CGSize)sizeThatFits:(CGSize)size</code>内针对不同情况重新计算出<code>button</code>的<code>size</code>，不然的话，系统会根据<code>image</code>和<code>title</code>的大小默认返回它们左右排列的<code>size</code>，此时的<code>size</code>是错误的，如图：</p><p><img src="http://upload-images.jianshu.io/upload_images/1792044-e2e1fb1c5d386379.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="没做适配的结果.png"></p><p>具体的布局分析思路就是这些了，因为代码太多，就不在这里粘贴详细代码了，如果需要代码的可以在文章底部找到demo的下载链接，demo里面也有详细的注释说明。</p><p>但是，到这里我们只是自定义了<code>image</code>和<code>title</code>的相对布局，我们的目的是自定义整个<code>UIButton</code>，所以系统默认的点击效果，<code>CALayer</code>的所有默认动画都需要移除掉，替换成我们自定义的<code>layer</code>效果。比如说系统<code>button</code>的默认高亮状态下图片颜色也会加深，这个其实很恶心，所以我们应该移除掉，就像图下所示：</p><p><img src="http://upload-images.jianshu.io/upload_images/1792044-149bd91391620709.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="系统button高亮状态.png"></p><p>ok，现在我们来整理一下需要的常用属性，分别为<code>normal</code>、<code>highlighted</code>、<code>disabled</code>这几种状态下的背景色，透明度变化，图片的<code>tintColor</code>，边框线的颜色，我们就针对这几个点进行修改。<br>下面粘贴几块代码段大概展示一下：<br><strong>highlighted逻辑</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setHighlighted:(<span class="built_in">BOOL</span>)highlighted &#123;</span><br><span class="line">    [<span class="keyword">super</span> setHighlighted:highlighted];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (highlighted &amp;&amp; !<span class="keyword">self</span>.originBorderColor) &#123;</span><br><span class="line">        <span class="comment">// 手指按在按钮上会不断触发setHighlighted:，所以这里做了保护，设置过一次就不用再设置了</span></span><br><span class="line">        <span class="keyword">self</span>.originBorderColor = [<span class="built_in">UIColor</span> colorWithCGColor:<span class="keyword">self</span>.layer.borderColor];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 渲染背景色</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.highlightedBackgroundColor || <span class="keyword">self</span>.highlightedBorderColor) &#123;</span><br><span class="line">        [<span class="keyword">self</span> adjustsButtonHighlighted];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 如果此时是disabled，则disabled的样式优先</span></span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.enabled) &#123;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 自定义highlighted样式</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.adjustsButtonWhenHighlighted) &#123;</span><br><span class="line">        <span class="keyword">if</span> (highlighted) &#123;</span><br><span class="line">            <span class="keyword">self</span>.alpha = <span class="number">0.5</span>f;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            [<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.25</span>f animations:^&#123;</span><br><span class="line">                <span class="keyword">self</span>.alpha = <span class="number">1</span>;</span><br><span class="line">            &#125;];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>enabled逻辑</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)setEnabled:(<span class="built_in">BOOL</span>)enabled &#123;</span><br><span class="line">    [<span class="keyword">super</span> setEnabled:enabled];</span><br><span class="line">    <span class="keyword">if</span> (!enabled &amp;&amp; <span class="keyword">self</span>.adjustsButtonWhenDisabled) &#123;</span><br><span class="line">        <span class="keyword">self</span>.alpha = <span class="number">0.5</span>f;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        [<span class="built_in">UIView</span> animateWithDuration:<span class="number">0.25</span>f animations:^&#123;</span><br><span class="line">            <span class="keyword">self</span>.alpha = <span class="number">1</span>;</span><br><span class="line">        &#125;];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>移除系统layer，添加自定义layer</strong></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)adjustsButtonHighlighted &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.highlightedBackgroundColor) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.highlightedBackgroundLayer) &#123;</span><br><span class="line">            <span class="keyword">self</span>.highlightedBackgroundLayer = [<span class="built_in">CALayer</span> layer];</span><br><span class="line">            [<span class="keyword">self</span>.highlightedBackgroundLayer FS_removeDefaultAnimations];</span><br><span class="line">            [<span class="keyword">self</span>.layer insertSublayer:<span class="keyword">self</span>.highlightedBackgroundLayer atIndex:<span class="number">0</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.highlightedBackgroundLayer.frame = <span class="keyword">self</span>.bounds;</span><br><span class="line">        <span class="keyword">self</span>.highlightedBackgroundLayer.cornerRadius = <span class="keyword">self</span>.layer.cornerRadius;</span><br><span class="line">        <span class="keyword">self</span>.highlightedBackgroundLayer.backgroundColor = <span class="keyword">self</span>.highlighted ? <span class="keyword">self</span>.highlightedBackgroundColor.CGColor : [<span class="built_in">UIColor</span> colorWithRed:<span class="number">1</span> green:<span class="number">1</span> blue:<span class="number">1</span> alpha:<span class="number">0</span>].CGColor;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">self</span>.highlightedBorderColor) &#123;</span><br><span class="line">        <span class="keyword">self</span>.layer.borderColor = <span class="keyword">self</span>.highlighted ? <span class="keyword">self</span>.highlightedBorderColor.CGColor : <span class="keyword">self</span>.originBorderColor.CGColor;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>因为需要大量的自定义属性来代替系统默认属性，虽然我很想在这里解释每个属性的用处，但是太麻烦了，所以还是建议直接下载demo，配合代码看文章，代码有详细的注释</p><p>这里就直接展示一下demo的效果图：</p><p><img src="http://upload-images.jianshu.io/upload_images/1792044-beb61c6dc89a4485.gif?imageMogr2/auto-orient/strip" alt="FSCustomButtonDemo.gif"></p><p>以前项目用到的时候，我也是直接网上找的一个库，不过那个库包含内容太多，很多都没用，所以我将其中的部分代码抽离了出来直接在项目中运用，效果还可以很稳定，所以最近抽时间将代码从项目中抽离封装了一下，写了一个demo上传在github，需要的可以直接前往下载：<br><a href="https://github.com/shunFSKi/FSCustomButtonDemo" target="_blank" rel="noopener">FSCustomButtonDemo</a></p><p>文章和demo中涉及到的知识点：<br><a href="http://error408.com/2016/08/02/%E6%9C%89%E6%9D%A1%E7%BA%BF%E5%8F%AB%E2%80%9C%E4%B8%80%E4%B8%AA%E5%83%8F%E7%B4%A0%E2%80%9D/" target="_blank" rel="noopener">有条线叫“一个像素”</a><br><a href="https://zsisme.gitbooks.io/ios-/content/chapter6/cashapelayer.html" target="_blank" rel="noopener">CALayer</a><br><a href="http://www.jianshu.com/p/d4607e0c14b1" target="_blank" rel="noopener">关于UIButton的UIEdgeInsets属性</a></p><p>如果对你有所帮助，就点个喜欢吧</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1792044-1a0d693d2497a0a7.jpg?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;=-=.jpg&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;需求背景&quot;&gt;&lt;a href=&quot;#需求背景&quot; class=&quot;headerlink&quot; title=&quot;需求背景&quot;&gt;&lt;/a&gt;需求背景&lt;/h2&gt;&lt;p&gt;日常开发中&lt;code&gt;UIButton&lt;/code&gt;的图片与标题默认的布局是固定的，是在水平方向左右排列。但是我们会经常需要更改&lt;code&gt;image&lt;/code&gt;和&lt;code&gt;title&lt;/code&gt;的位置来实现需求，这是个很常见的需求就不多说了。所以下面就来谈谈如何一步步的实现一个高度自定义的&lt;code&gt;UIButton&lt;/code&gt;控件。&lt;/p&gt;
    
    </summary>
    
      <category term="控件" scheme="https://shunfski.github.io/categories/%E6%8E%A7%E4%BB%B6/"/>
    
    
      <category term="技术" scheme="https://shunfski.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="iOS" scheme="https://shunfski.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS一种动态栅格布局方案</title>
    <link href="https://shunfski.github.io/2017/06/10/FSGridLayoutDemo/"/>
    <id>https://shunfski.github.io/2017/06/10/FSGridLayoutDemo/</id>
    <published>2017-06-10T12:18:00.000Z</published>
    <updated>2017-06-28T14:47:15.000Z</updated>
    
    <content type="html"><![CDATA[<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>在日常开发过程中，我们会遇到一些需要不定期动态改变布局的页面或视图块，下面用张图展示一下：</p><p><img src="http://upload-images.jianshu.io/upload_images/1792044-0441a2b49f361528.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="zdm_home.png"><br>我以这张图解释一下需求，图上的几块都是需要显示不同的功能模块，点击的时候也需要跳转到不同页面。这个布局实现很简单，但是如果这个布局需要不定期的更改，比如A换到右边，大小发生变化等不确定因素，我们不可能就发布一个新的版本去修改这个页面。所以大部分人会选择<code>webView</code>来实现，或者事先约定好几种布局格式，由后台来随时改变布局。</p><a id="more"></a><h2 id="解决思路"><a href="#解决思路" class="headerlink" title="解决思路"></a>解决思路</h2><p>事实上这一块并占不了整个页面，大部分情况下只是在<code>tableView</code>中嵌套一截这样的需求，我公司项目的实现用的一直是<code>webView</code>来实现，但是这样就会有很多不必要的问题，比如<code>webView</code>的高度计算，如果客户端来计算高度，在一些网络不稳定情况下，<code>webView</code>的资源没有加载完全，高度就会出现偏差，而且<code>webView</code>的加载速度，性能，和<code>js</code>的交互都是很不理想的。（总之，我大原生就是不爱用h5啦）<br>这里其实有两种<strong>解决方案</strong>：</p><ul><li>方案1：和后台约定好几种布局样式，客户端根据后台参数来动态显示。</li><li>方案2：这块视图看为一个整体，根据<code>json</code>数据将其分为X个子块，理论上可以根据数据无限分割下去。</li></ul><p><strong>优缺点</strong>：<br>第一种方案实现简单，而且可以应付日常所需，但是提前约定的格式必定不会太多，不够灵活。<br>第二种方案完全根据数据决定布局，子块可以无限分割下去，布局灵活，但是数据比较复杂。<br>实际上第二种布局是最近公司安卓小哥想出来 一个思路，我和他分别实现了一下，发现效果很好。<a href="http://www.jianshu.com/u/9095ceab041d" target="_blank" rel="noopener">这里是安卓小哥的简书</a>。</p><h2 id="具体实现"><a href="#具体实现" class="headerlink" title="具体实现"></a>具体实现</h2><p>下面来和大家说一下具体的实现思路：</p><p><img src="http://upload-images.jianshu.io/upload_images/1792044-3f99846aba74bcf7.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="zdm_home.png"></p><p>我们还是以这张图为例：<br>1、我们首先定义两个<code>row</code>和<code>item</code>元素，分别对应行和块的概念。如上图分为两行，A那里代表一整行，下面的四小块代表一整行。分割为<code>row1</code>和<code>row2</code>。<br>2、<code>row1</code>：分割为AB两块，水平排列，宽度比<code>2：3</code></p><ul><li>A不用再分，直接显示图片</li><li>B分为B1、B2两块，垂直排列，高度比<code>1：1</code></li><li>B2分为D、E两块，水平排列，宽度比<code>1：1</code><br><code>row2</code>：分割为<code>1：1：1：1</code>的四小块</li></ul><p><code>json</code>数据的结构如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    &quot;images&quot;: [</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;children&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;image&quot;: &quot;https://i.huim.com/miaoquan/14966511524892.SS2!/both/300x300/unsharp/true&quot;,</span><br><span class="line">                    &quot;weight&quot;: 2</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;children&quot;: [</span><br><span class="line">                        &#123;</span><br><span class="line">                            &quot;image&quot;: &quot;https://i.huim.com/miaoquan/14963170206106.jpg!/both/300x300/unsharp/true&quot;,</span><br><span class="line">                            &quot;weight&quot;: 1</span><br><span class="line">                        &#125;,</span><br><span class="line">                        &#123;</span><br><span class="line">                            &quot;children&quot;: [</span><br><span class="line">                                &#123;</span><br><span class="line">                                    &quot;image&quot;: &quot;https://i.huim.com/miaoquan/14968041079523.jpg!/compress/true/both/300x300&quot;,</span><br><span class="line">                                    &quot;weight&quot;: 1</span><br><span class="line">                                &#125;,</span><br><span class="line">                                &#123;</span><br><span class="line">                                    &quot;image&quot;: &quot;https://i.huim.com/miaoquan/14968026112335.jpg!/compress/true/both/300x300&quot;,</span><br><span class="line">                                    &quot;weight&quot;: 1</span><br><span class="line">                                &#125;</span><br><span class="line">                            ],</span><br><span class="line">                            &quot;orientation&quot;: &quot;h&quot;,</span><br><span class="line">                            &quot;weight&quot;: 1</span><br><span class="line">                        &#125;</span><br><span class="line">                    ],</span><br><span class="line">                    &quot;orientation&quot;: &quot;v&quot;,</span><br><span class="line">                    &quot;weight&quot;: 3</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;height&quot;: 212,</span><br><span class="line">            &quot;orientation&quot;: &quot;h&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &#123;</span><br><span class="line">            &quot;children&quot;: [</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;image&quot;: &quot;https://i.huim.com/miaoquan/14929203253142.SS2!/both/300x300/unsharp/true&quot;,</span><br><span class="line">                    &quot;weight&quot;: 1</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;image&quot;: &quot;https://i.huim.com/contents/14828912708690.jpg!/both/300x300/unsharp/true&quot;,</span><br><span class="line">                    &quot;weight&quot;: 1</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;image&quot;: &quot;https://i.huim.com/miaoquan/14968146185109.jpg!/both/300x300/unsharp/true&quot;,</span><br><span class="line">                    &quot;weight&quot;: 1</span><br><span class="line">                &#125;,</span><br><span class="line">                &#123;</span><br><span class="line">                    &quot;image&quot;: &quot;https://i.huim.com/miaoquan/14968145059484.jpg!/both/300x300/unsharp/true&quot;,</span><br><span class="line">                    &quot;weight&quot;: 1</span><br><span class="line">                &#125;</span><br><span class="line">            ],</span><br><span class="line">            &quot;height&quot;: 138,</span><br><span class="line">            &quot;orientation&quot;: &quot;h&quot;</span><br><span class="line">        &#125;</span><br><span class="line">    ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>数据说明：<br><code>images</code>：数组，数组的元素个数决定了整个<code>View</code>需要分为几行<code>row</code><br><code>children</code>：数组，数组元素个数决定了每个<code>row</code>需要分为多少个块<code>item</code><br><code>height</code>：<code>row</code>的高度<br><code>orientation</code>：布局方向，<code>v</code>和<code>h</code>，分别对应垂直和水平方向<br><code>image</code>：该子块显示的图片<br><code>weight</code>：在这一块中的权重比</p><p><strong>最重要的是对这个数据的处理</strong>，children代表了块，这里用到了递归的思想，只要这一层的数据有children，就需要一直分割下去，直到children为<code>null</code>，停止分割，显示图片。这里的数据层次较深，逻辑需要处理清晰。</p><p>不得不说，安卓小哥的当时提出了这个思路吸引到了我，和他分别实现了过后发现十分好用。这刚好解决了我公司项目中遇到的问题，如果衍生出去，其实可以代替很多地方的布局方式。这种布局灵活度很高，完全由后端数据控制，是个很棒的想法。</p><p>下面展示一下我实现的效果图：</p><p><img src="http://upload-images.jianshu.io/upload_images/1792044-e85b4b6c9f9f9caf.gif?imageMogr2/auto-orient/strip" alt="FSGridLayoutDemo.gif"></p><p>上面的边框线是我方便区分每一块加上的，实际开发可以忽略。若果需要每个子块的跳转信息，可以在<code>image</code>那一层加一个参数。比如我公司是定义了一个页面跳转协议，客户端，前端，后端都是遵循这个协议，我举个例子，加了一个跳转参数<code>&quot;pushurl&quot;:&quot;huim://detail?id=1234&quot;</code>，我就知道这块需要跳转到商品id为1234的详情页。实现了高度动态化布局和跳转。我也不知道该称之为什么布局，所以暂时称之为<strong>栅格化布局</strong>。</p><h2 id="局限性"><a href="#局限性" class="headerlink" title="局限性"></a>局限性</h2><p>这个布局正如我文章所述，一般是用来实现那种轻量级的页面，我主要是用来替代那种嵌套的<code>webView</code>的，如果太过复杂的页面当然就没有这个必要了。当然可以衍生出去可能会有适合你自己项目的地方。所以，酌情使用吧。</p><p>我写的<a href="https://github.com/shunFSKi/FSGridLayoutDemo" target="_blank" rel="noopener">demo在这里</a>，想要看具体实现的可以前往下载，欢迎提出更好的实现方式。</p><p>如果对你有所帮助和启发，不妨点个喜欢</p><p><img src="http://upload-images.jianshu.io/upload_images/1792044-cdf06361b9701eed.png?imageMogr2/auto-orient/strip" alt="68fc9e97e32f8d394891bde8424dfac5.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;h2 id=&quot;前言&quot;&gt;&lt;a href=&quot;#前言&quot; class=&quot;headerlink&quot; title=&quot;前言&quot;&gt;&lt;/a&gt;前言&lt;/h2&gt;&lt;p&gt;在日常开发过程中，我们会遇到一些需要不定期动态改变布局的页面或视图块，下面用张图展示一下：&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1792044-0441a2b49f361528.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240&quot; alt=&quot;zdm_home.png&quot;&gt;&lt;br&gt;我以这张图解释一下需求，图上的几块都是需要显示不同的功能模块，点击的时候也需要跳转到不同页面。这个布局实现很简单，但是如果这个布局需要不定期的更改，比如A换到右边，大小发生变化等不确定因素，我们不可能就发布一个新的版本去修改这个页面。所以大部分人会选择&lt;code&gt;webView&lt;/code&gt;来实现，或者事先约定好几种布局格式，由后台来随时改变布局。&lt;/p&gt;
    
    </summary>
    
      <category term="布局" scheme="https://shunfski.github.io/categories/%E5%B8%83%E5%B1%80/"/>
    
    
      <category term="技术" scheme="https://shunfski.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="iOS" scheme="https://shunfski.github.io/tags/iOS/"/>
    
  </entry>
  
  <entry>
    <title>iOS scrollView嵌套tableView的手势冲突解决方案</title>
    <link href="https://shunfski.github.io/2017/06/07/FSScrollViewNestTableView/"/>
    <id>https://shunfski.github.io/2017/06/07/FSScrollViewNestTableView/</id>
    <published>2017-06-07T13:24:00.000Z</published>
    <updated>2017-06-28T14:48:27.000Z</updated>
    
    <content type="html"><![CDATA[<p>在平时项目中，我们经常会碰到类似<code>UIScrollView</code>嵌套<code>UITableView</code>的需求，虽然苹果并不建议这种做法，但是这样的需求在平时工作中还是很常见的。比如笔者公司项目之前用到的地方：<br><img src="http://upload-images.jianshu.io/upload_images/1792044-ec83d82069011023.gif?imageMogr2/auto-orient/strip" alt="FSScrollViewNestTableViewDemo.gif"></p><p>可以看到最上面是一块轮播图组件，我也已经整理了<a href="https://github.com/shunFSKi/FSLoopScrollView" target="_blank" rel="noopener">一份轮播图组件在github上面</a>，轮播图下面还有若干条其他的内容，而且这几块内容都是后台动态控制显示的，所以这里用<code>UIScrollView</code>设置顶部偏移量实现是很不方便的。最外层我肯定选择使用<code>tableView</code>分区管理来实现。而下面的横向分类页面肯定需要<code>tableView</code>去实现</p><a id="more"></a><p>这样的话问题就来了，先不说下面的横向分页如何实现，这个页面必定需要在一个<code>tableView</code>中嵌套多个不同的<code>tableView</code>，但是如果嵌套了其他的<code>scrollView</code>，就需要我们判断不同条件下让哪个<code>scrollView</code>响应滑动事件，因此这里我们需要解决的就是<strong>手势的冲突问题</strong>。</p><p>最开始想到的是在滑动<code>tableView</code>时候根据偏移量设置<code>scrollEnabled</code>来控制两个<code>tableView</code>的响应，但是会有个问题就是当滚动到顶部时用户必须第二次滑动才可以显示出外层的<code>tableView</code>，这样就会造成一个卡顿的效果，所以这个方法是行不通的。</p><p>下面说一下我的解决思路：<br>这里就直接分为<code>mainTableView</code>和<code>subTableView</code>，设置<code>mainTableView</code>的联动手势<code>UIGestureRecognizer</code></p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> 同时识别多个手势</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment"> @param gestureRecognizer gestureRecognizer description</span></span><br><span class="line"><span class="comment"> @param otherGestureRecognizer otherGestureRecognizer description</span></span><br><span class="line"><span class="comment"> @return return value description</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">- (<span class="built_in">BOOL</span>)gestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(<span class="built_in">UIGestureRecognizer</span> *)otherGestureRecognizer</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">YES</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>下面的分类<code>pageView</code>是直接使用了封装的page框架<a href="https://github.com/shunFSKi/FSScrollContentView" target="_blank" rel="noopener">FSScrollContentView</a>，在<code>mainTableView</code>的<code>UIScrollViewDelegate</code>方法内判断<code>mainTableView</code>的偏移量，当标题栏滚动到顶部的时候固定<code>mainTableView</code>的偏移量</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">CGFloat</span> bottomCellOffset = [_tableView rectForSection:<span class="number">1</span>].origin.y - <span class="number">64</span>;</span><br><span class="line">    <span class="keyword">if</span> (scrollView.contentOffset.y &gt;= bottomCellOffset) &#123;</span><br><span class="line">        scrollView.contentOffset = <span class="built_in">CGPointMake</span>(<span class="number">0</span>, bottomCellOffset);</span><br><span class="line">        <span class="keyword">if</span> (<span class="keyword">self</span>.canScroll) &#123;</span><br><span class="line">            <span class="keyword">self</span>.canScroll = <span class="literal">NO</span>;</span><br><span class="line">            <span class="keyword">self</span>.contentCell.cellCanScroll = <span class="literal">YES</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.canScroll) &#123;<span class="comment">//子视图没到顶部</span></span><br><span class="line">            scrollView.contentOffset = <span class="built_in">CGPointMake</span>(<span class="number">0</span>, bottomCellOffset);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.tableView.showsVerticalScrollIndicator = _canScroll?<span class="literal">YES</span>:<span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>上面代码中的<code>canScroll</code>是定义的一个<code>BOOL</code>变量用来控制<code>mainTableView</code>的偏移量</p><p>此时，<code>subTableView</code>收到可以滚动的信号<code>cellCanScroll</code>，才开始响应滑动的手势，在<code>subTableView</code>的<code>UIScrollViewDelegate</code>方法内实现：</p><figure class="highlight objc"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">- (<span class="keyword">void</span>)scrollViewDidScroll:(<span class="built_in">UIScrollView</span> *)scrollView</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (!<span class="keyword">self</span>.vcCanScroll) &#123;</span><br><span class="line">        scrollView.contentOffset = <span class="built_in">CGPointZero</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (scrollView.contentOffset.y &lt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="keyword">self</span>.fingerIsTouch) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">self</span>.vcCanScroll = <span class="literal">NO</span>;</span><br><span class="line">        scrollView.contentOffset = <span class="built_in">CGPointZero</span>;</span><br><span class="line">        [[<span class="built_in">NSNotificationCenter</span> defaultCenter] postNotificationName:<span class="string">@"leaveTop"</span> object:<span class="literal">nil</span>];<span class="comment">//到顶通知父视图改变状态</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">self</span>.tableView.showsVerticalScrollIndicator = _vcCanScroll?<span class="literal">YES</span>:<span class="literal">NO</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其实到这里会发现主要是通过设置两个<code>scrollView</code>的偏移量来解决这个手势冲突的问题。因为代码已经表达的很清楚，不太擅长表达，这里只是大概描述一下使用场景。</p><p>具体的实现方式已经写成了一个demo，里面也有详细的注释，可以前去下载：<a href="https://github.com/shunFSKi/FSScrollViewNestTableView" target="_blank" rel="noopener">FSScrollViewNestTableView</a></p><hr><p><strong>2017.6.21–应网友要求，demo添加了刷新逻辑</strong></p><hr><p>给大家看一下实现后的效果图：</p><p><img src="http://upload-images.jianshu.io/upload_images/1792044-a2e78c7d05133233.gif?imageMogr2/auto-orient/strip" alt="FSScrollViewNestTableView.gif"></p><h2 id="这里只是提供了一种解决方案，欢迎提出问题多多交流"><a href="#这里只是提供了一种解决方案，欢迎提出问题多多交流" class="headerlink" title="这里只是提供了一种解决方案，欢迎提出问题多多交流"></a>这里只是提供了一种解决方案，欢迎提出问题多多交流</h2>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;在平时项目中，我们经常会碰到类似&lt;code&gt;UIScrollView&lt;/code&gt;嵌套&lt;code&gt;UITableView&lt;/code&gt;的需求，虽然苹果并不建议这种做法，但是这样的需求在平时工作中还是很常见的。比如笔者公司项目之前用到的地方：&lt;br&gt;&lt;img src=&quot;http://upload-images.jianshu.io/upload_images/1792044-ec83d82069011023.gif?imageMogr2/auto-orient/strip&quot; alt=&quot;FSScrollViewNestTableViewDemo.gif&quot;&gt;&lt;/p&gt;
&lt;p&gt;可以看到最上面是一块轮播图组件，我也已经整理了&lt;a href=&quot;https://github.com/shunFSKi/FSLoopScrollView&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;一份轮播图组件在github上面&lt;/a&gt;，轮播图下面还有若干条其他的内容，而且这几块内容都是后台动态控制显示的，所以这里用&lt;code&gt;UIScrollView&lt;/code&gt;设置顶部偏移量实现是很不方便的。最外层我肯定选择使用&lt;code&gt;tableView&lt;/code&gt;分区管理来实现。而下面的横向分类页面肯定需要&lt;code&gt;tableView&lt;/code&gt;去实现&lt;/p&gt;
    
    </summary>
    
      <category term="手势" scheme="https://shunfski.github.io/categories/%E6%89%8B%E5%8A%BF/"/>
    
    
      <category term="技术" scheme="https://shunfski.github.io/tags/%E6%8A%80%E6%9C%AF/"/>
    
      <category term="iOS" scheme="https://shunfski.github.io/tags/iOS/"/>
    
  </entry>
  
</feed>
